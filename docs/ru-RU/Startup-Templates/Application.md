# Стартовый iаблон приложения

## Вступление 


Этот шаблон обеспечивает многоуровневую структуру приложения, основанную на практике [Domain Driven Design](../Domain-Driven-Design.md) (DDD).

В этом документе подробно объясняется **структура решения** и проекты. Если вы хотите начать быстро, следуйте приведенным ниже инструкциям: 

* [The getting started document](../Getting-Started-With-Startup-Templates.md) объясняет, как создать новое приложение за несколько минут. 
* [The application development tutorial](../Tutorials/Part-1) пошаговая разработка приложения. 

## С чего начать? 

Вы можете использовать [ABP CLI](../CLI.md) для создания нового проекта с использованием этого стартового шаблона. Или вы можете напрямую создать и загрузить шаблон на странице [Начало работы](https://abp.io/get-started). Далее используется подход CLI. 

Сначала установите ABP CLI, если вы еще не устанавливали его: 

````bash
dotnet tool install -g Volo.Abp.Cli
````
Затем используйте команду `abp new` в пустой папке, чтобы создать новое решение: 

````bash
abp new Acme.BookStore -t app
````

* `Acme.BookStore` это имя решения, например *YourCompany.YourProduct*. Вы можете использовать одноуровневое, двухуровневое или трехуровневое именование. 
* В этом примере указано имя шаблона (`-t` or `--template` option). Однако, `app`  уже является шаблоном по умолчанию, если вы его не укажете. 

### Выберете фреймворк пользовательского интерфейса

Этот шаблон предоставляет несколько фреймворков пользовательского интерфейса: 

* `mvc`: Пользовательский интерфейс ASP.NET Core MVC с Razor Pages (по умолчанию) 
* `blazor`: Blazor UI
* `angular`: Angular UI

Используйте параметр -u или --ui, чтобы указать конкретный фреймворк пользовательского интерфейса: 

````bash
abp new Acme.BookStore -u angular
````

### Укажите провайдера базы данных

Поддерживаемые типы провайдеров базы данных:

- `ef`: Entity Framework Core (по умолчанию)
- `mongodb`: MongoDB

Используйте опцию `-d` (или `--database-provider`) для указания конкретного типа провайдера базы данных:

````bash
abp new Acme.BookStore -d mongodb
````

### Укажите платформу мобильного приложения 

Этот шаблон поддерживает следующие платформы мобильных приложений:

- `react-native`: React Native

Используйте опцию `-m` (or `--mobile`) для указания конкретной платформы мобильного приложения:

````bash
abp new Acme.BookStore -m react-native
````

Если опция не указана, мобильное приложение создано не будет.

## Структура решения

В зависимости от указанных вами вариантов вы можете получить различную структуру решения.

### Структура по умолчанию

Если вы не укажете никаких дополнительных опций, у вас будет решение, подобное показанному ниже:

![bookstore-visual-studio-solution-v3](../images/bookstore-visual-studio-solution-v3.png)

Проекты организованы в папки `src` и `test`. Папка `src` содержит фактическое приложение, которое разбито на уровни на основе принципов [DDD](../Domain-Driven-Design.md), как упоминалось ранее.

На схеме ниже показаны уровни и зависимости приложения от проекта:

![layered-project-dependencies](../images/layered-project-dependencies.png)

Каждый раздел ниже объясняет связанный проект и его зависимости.

#### Слой/Проект .Domain.Shared

Этот проект содержит константы, перечисления и другие объекты, которые на самом деле являются частью уровня домена, но должны использоваться всеми слоями/проектами в решении.

Перечисление `BookType` и класс `BookConsts` (которые могут иметь некоторые постоянные поля для сущности `Book`, например `MaxNameLength`) являются хорошими кандидатами для этого проекта.

* Этот проект не зависит от других проектов в решении. Все остальные проекты прямо или косвенно зависят от этого.

#### Слой/Проект .Domain

Это доменный слой решения. В основном он содержит [entities, aggregate roots](../Entities.md), [службы домена] (../ Domain-Services.md), [domain services](../Domain-Services.md), [value objects](../Value-Objects.md), [repository interfaces](../Repositories.md) и другие объекты домена.

Сущность `Book`, доменная служба `BookManager` и интерфейс `IBookRepository` - хорошие элементы для этого проекта.

* Зависит от `.Domain.Shared`, потому что он использует константы, перечисления и другие объекты, определенные в этом проекте.

#### Слой/Проект .Application.Contracts

Этот проект в основном содержит [application service](../Application-Services.md) **интерфейсы** и [Data Transfer Objects](../Data-Transfer-Objects.md) (DTO) уровня приложения. Он существует для разделения интерфейса и реализации прикладного уровня. Таким образом, проект интерфейса может быть предоставлен клиентам как пакет контракта.

Интерфейс `IBookAppService` и класс `BookCreationDto` являются хорошими кандидатами для этого проекта.

* Зависит от `.Domain.Shared`, потому что он может использовать константы, перечисления и другие общие объекты этого проекта в интерфейсах служб приложений и DTO.

#### Слой/Проект .Application

Данный проект [application service](../Application-Services.md) **Имплементирует** интерфейсы определенных в проекте `.Application.Contracts`.

Класс `BookAppService` - хороший кандидат для этого проекта.

* Зависит от проекта `.Application.Contracts`, чтобы иметь возможность реализовывать интерфейсы и использовать DTO.

* Зависит от проекта `.Domain`, чтобы иметь возможность использовать объекты домена (сущности, интерфейсы репозитория ... и т. Д.) Для выполнения логики приложения.

#### Слой/Проект .EntityFrameworkCore

Это проект интеграции с EF Core. Он определяет `DbContext` и реализует интерфейсы репозитория, определенные в проекте .Domain.

* Зависит от проекта `.Domain`, чтобы иметь возможность ссылаться на сущности и интерфейсы репозитория. 

>Этот проект доступен, только если вы используете EF Core в качестве поставщика базы данных. Если вы выберете другого поставщика базы данных, его имя будет другим.

#### Слой/Проект .EntityFrameworkCore.DbMigrations

Содержит миграции базы данных EF Core для решения. Он имеет отдельный `DbContext`, предназначенный для управления миграциями.

ABP - это модульный фреймворк с идеальным дизайном, каждый модуль имеет свой собственный класс DbContext. Здесь в игру вступает миграция `DbContext`, которая объединяет все конфигурации` DbContext` в единую модель для поддержки единой схемы базы данных. Для более сложных сценариев у вас может быть несколько баз данных (каждая содержит одну или несколько таблиц модулей) и множественный перенос `DbContext`s (каждая поддерживает свою схему базы данных).

Обратите внимание, что миграция `DbContext` используется только для миграции базы данных и *не используется в runtime*.

* Зависит от проекта `.EntityFrameworkCore`, поскольку он повторно использует конфигурацию, определенную для` DbContext` приложения.

> Этот проект доступен, только если вы используете EF Core в качестве поставщика базы данных.
>
> Смотрите [Entity Framework Core Migrations Guide](../Entity-Framework-Core-Migrations.md), чтобы понять этот проект более подробно.

#### Слой/Проект .DbMigrator 

Это консольное приложение, которое упрощает выполнение миграции базы данных в средах разработки и на боевом сервере. Когда вы запускаете это приложение, оно;

* При необходимости создает базу данных.
* Применяет незавершенные миграции базы данных.
* При необходимости засевает исходные данные.

> У этого проекта есть собственный файл `appsettings.json`. Итак, если вы хотите изменить строку подключения к базе данных, не забудьте изменить и этот файл.

На этом этапе особенно важен инициализация исходных данных. ABP имеет модульную инфраструктуру с иначальной структурой данных. См. [its documentation](../Data-Seeding.md) для получения дополнительной информации о заполнении данных.

Хотя создание базы данных и применение миграции необходимо только для реляционных баз данных, эти проекты появляются, даже если вы выбираете поставщика базы данных NoSQL (например, MongoDB). В этом случае он по-прежнему сохраняет исходную структуру, необходимые для приложения.

* Зависит от `.EntityFrameworkCore.DbMigrations` проекта (для EF Core), поскольку ему требуется доступ к миграциям.
* Зависит от проекта `.Application.Contracts`, чтобы иметь возможность доступа к определениям разрешений, поскольку начальная инициализация данных требует разрешения в качестве роли администратора.

#### Слой/Проект .HttpApi

Этот проект используется для определения ваших контроллеров API. 

В большинстве случаев вам не нужно вручную определять контроллеры API, поскольку функция ABP [Auto API Controllers](../API/Auto-API-Controllers.md) создает их автоматически на основе слоя Application вашего приложения. Однако, если вам нужно написать контроллеры API, это лучшее место для этого. 

* Зависит от проекта `.Application.Contracts`, чтобы иметь возможность внедрять интерфейсы служб приложения. 

#### Слой/Проект .HttpApi.Client

Это проект, который определяет клиентские прокси C# для использования HTTP API решения. Вы можете поделиться этой библиотекой со сторонними клиентами, чтобы они могли легко использовать ваши HTTP API в своих приложениях Dotnet (для других типов приложений они по-прежнему могут использовать ваши API вручную или с помощью инструмента на своей собственной платформе) 

В большинстве случаев вам не нужно вручную создавать клиентские прокси на C# благодаря функции ABP [Dynamic C# API Clients](../API/Dynamic-CSharp-API-Clients.md). 

Проект `.HttpApi.Client.ConsoleTestApp` - это консольное приложение, созданное для демонстрации использования клиентских прокси. 

* Зависит от проекта `.Application.Contracts`, чтобы иметь возможность совместно использовать одни и те же интерфейсы служб приложений и DTO с удаленной службой. 

> Вы можете удалить этот проект и зависимости, если вам не нужно создавать клиентские прокси C# для ваших API. 

#### Проект .Web

Этот проект содержит пользовательский интерфейс (UI) приложения, если вы используете пользовательский интерфейс ASP.NET Core MVC. Он содержит страницы Razor, файлы JavaScript, файлы CSS, изображения и так далее ... 

Этот проект содержит основной файл `appsettings.json`, который содержит строку подключения и другую конфигурацию приложения. 

* Зависит от `.HttpApi`, поскольку слой пользовательского интерфейса должен использовать API и интерфейсы служб приложений решения. 

> Если вы проверите исходный код файла `.Web.csproj`, вы увидите ссылки на проекты` .Application` и `.EntityFrameworkCore.DbMigrations`. 
>
> Эти ссылки на самом деле не нужны при кодировании слоя пользовательского интерфейса, поскольку уровень пользовательского интерфейса обычно не зависит от реализации EF Core или слоя приложения. Эти стартовые шаблоны готовы для раздельного развертывания, когда когда API размещается на отдельном сервере, а не на совместно со слоем пользовательского интерфейса. 
>
> Однако, если вы не укажете опцию `--tiered`, эти ссылки будут в проекте .Web, чтобы иметь возможность размещать веб-слои, API и уровни приложений в одной конечной точке приложения. 
>
> Это дает вам возможность использовать объекты домена и репозитории на уровне представления. Хотя и согласно DDD, это считается плохой практикой. 

#### Проекты Test

В решении есть несколько тестовых проектов, по одному для каждого слоя: 

* `.Domain.Tests` используется для тестирования слоя домена.
* `.Application.Tests` используется для тестирования слоя приложения.
* `.EntityFrameworkCore.Tests` используется для тестирования конфигурации EF Core и настраиваемых репозиториев.
* `.Web.Tests` используется для тестирования пользовательского интерфейса (если вы используете пользовательский интерфейс ASP.NET Core MVC).
* `.TestBase` - это базовый (общий) проект для всех тестов. 

Кроме того, `.HttpApi.Client.ConsoleTestApp` - это консольное приложение (не автоматизированный тестовый проект), демонстрирующее использование HTTP API из приложения .NET. 

Тестовые проекты подготовлены к интеграционному тестированию;

* Они полностью интегрирован в структуру ABP и все службы в вашем приложении.
* Они использует базу данных SQLite в памяти для EF Core. Для MongoDB используется библиотека [Mongo2Go](https://github.com/Mongo2Go/Mongo2Go).
* Авторизация отключена, поэтому любое приложение-сервис можно легко использовать в тестах. 

Вы по-прежнему можете создавать модульные тесты для своих классов, которые будет сложнее написать (потому что вам нужно будет подготовить mock/fake объекты), но быстрее запустить (потому что он тестирует только один класс и пропускает весь процесс инициализации). 

#### Как запустить? 

Установите `.Web` в качестве запускаемого проекта и запустите приложение. Имя пользователя по умолчанию - `admin`, пароль - `1q2w3E*`. 

Смотрите более подробно [Getting Started With the ASP.NET Core MVC Template](../Getting-Started-AspNetCore-MVC-Template.md).

### Многоуровневая/Многослойная структура 

Если вы выбрали пользовательский интерфейс ASP.NET Core и указали параметр --tiered, созданное решение будет многоуровневым. Назначение многоуровневой структуры - иметь возможность **развертывать веб-приложение и HTTP API на разных серверах**: 

![bookstore-visual-studio-solution-v3](../images/tiered-solution-servers.png)

* Браузер отображает ваш пользовательский интерфейс, выполняя HTML, CSS и JavaScript.
* Веб-сервер содержат статические файлы пользовательского интерфейса (CSS, JavaScript, изображения и т. Д.) И динамические компоненты (например, страницы Razor). Он выполняет HTTP-запросы к серверу API для выполнения бизнес-логики приложения.
* Сервер API содержит HTTP API, которые затем используют уровни приложения и домена приложения для выполнения бизнес-логики.
* Наконец, сервер баз данных размещает вашу базу данных. 

Таким образом, получившееся решение допускает четырехуровневое развертывание по сравнению с трехуровневым развертыванием структуры по умолчанию, описанной ранее. 

> Если вам действительно не нужно такое четырехуровневое развертывание, рекомендуется использовать структуру по умолчанию, которую проще разрабатывать, развертывать и поддерживать. 

Структура решения показана ниже: 

![bookstore-visual-studio-solution-v3](../images/bookstore-visual-studio-solution-tiered.png)

В отличие от структуры по умолчанию, в игру вступают два новых проекта: `.IdentityServer` и `.HttpApi.Host`.

#### Проект .IdentityServer

Этот проект используется в качестве сервера аутентификации для других проектов. Проект `.Web` использует аутентификацию OpenId Connect для получения идентификаторов и токенов доступа для текущего пользователя с IdentityServer. Затем использует токен доступа для вызова HTTP API-сервера. Сервер HTTP API использует аутентификацию токена-носителя для получения утверждений от токена доступа для авторизации текущего пользователя. 

![tiered-solution-applications](../images/tiered-solution-applications.png)

ABP использует платформу [IdentityServer4](https://identityserver.io/) с открытым исходным кодом для аутентификации между приложениями. См. [Документацию IdentityServer4](http://docs.identityserver.io) для получения подробной информации о протоколе IdentityServer4 и OpenID Connect. 

У него есть собственный `appsettings.json`, который содержит соединение с базой данных и другие конфигурации. 

#### Проект .HttpApi.Host

Этот проект представляет собой приложение, в котором размещен API решения. У него есть собственный `appsettings.json`, который содержит соединение с базой данных и другие конфигурации. 

#### Проект .Web

Как и структура по умолчанию, этот проект содержит пользовательский интерфейс (UI) приложения. Он содержит razor страницы, файлы JavaScript, файлы стилей, изображения и т. Д. 

Этот проект содержит файл `appsettings.json`, но на этот раз у него нет строки подключения, потому что он никогда не подключается к базе данных. Вместо этого он в основном содержит конечную точку удаленного сервера API и сервера аутентификации. 

#### Предварительные требования 

* [Redis](https://redis.io/): Приложения используют Redis как распределенный кеш. Вам необходимо установить и запустить Redis. 

#### Как запустить? 

Вы должны запустить приложение в указанном порядке:

* Сначала запустите `.IdentityServer`, так как от него зависят другие приложения.
* Затем запустите `.HttpApi.Host`, поскольку он используется приложением` .Web`.
* Наконец, вы можете запустить проект `.Web` и войти в приложение (используя `admin` в качестве имени пользователя и `1q2w3E*` в качестве пароля). 

### Angular UI

Если вы выберете `Angular` в качестве UI-фреймворка (используя параметр `-u angular`), решение будет разделено на две папки: 

* `angular` Папка содержит приложение Angular UI, клиентский код для браузера. 
* `aspnet-core` папка содержит решение ASP.NET Core, бекенд.

На стороне сервера аналогично описанному выше решению. Проект `*.HttpApi.Host` обслуживает API, а приложение` Angular` использует его.

Структура папок приложения Angular выглядит следующим образом: 

![angular-folder-structure](../images/angular-folder-structure.png)

Каждый из коммерческих модулей ABP представляет собой пакет NPM. Некоторые модули ABP добавляются как зависимость в `package.json`. Эти модули устанавливаются вместе со своими зависимостями. Чтобы увидеть все пакеты ABP, вы можете запустить следующую команду в папке `angular`: 

```bash
yarn list --pattern abp
```

Структура модуля Angular приложения: 

![Angular template structure diagram](../images/angular-template-structure-diagram.png)

#### AppModule

`AppModule` - корневой модуль приложения. Некоторые из модулей ABP и некоторые важные модули импортированы в `AppModule`. 

ABP Config modules также были импортированы в `AppModule` и могут быть инициализированны с помощью lazy-loadable ABP modules. 

#### AppRoutingModule

В AppRoutingModule есть лениво загрузка ABP модулей в виде маршрутов. 

> Пути модулей ABP не изменены.

Вы должны добавить свойство `routes` в объект` data`, чтобы добавить в меню ссылку для перенаправления на ваши пользовательские страницы. 

```js
{
   path: 'dashboard',
   loadChildren: () => import('./dashboard/dashboard.module').then(m => m.DashboardModule),
   canActivate: [AuthGuard, PermissionGuard],
   data: {
      routes: {
         name: 'ProjectName::Menu:Dashboard',
         order: 2,
         iconClass: 'fa fa-dashboard',
         requiredPolicy: 'ProjectName.Dashboard.Host'
      } as ABP.Route
   }
}
```
В приведенном выше примере; 
*  Если пользователь не вошел в систему, AuthGuard блокирует доступ и перенаправляет на страницу входа. 
*  PermissionGuard проверяет права пользователя с помощью свойства `requiredPolicy` объекта `rotues`. Если пользователь не авторизован для доступа к странице, отобразится страница 403. 
*  Свойство `name` для` routes` является текстом меткой меню и может использоватся в качестве ключа при локализации.
*  Свойство `iconClass` объекта` routes` является классом задающим иконку меню
*  Свойство `requiredPolicy` объекта` routes` является обязательным ключом политики для доступа к странице. 

После указанного выше определения `routes`, если пользователь авторизован, в dashboard отобразится соответствующая ссылка меню. 

#### Shared Module

Модули, функционал которых могут потребоваться для всех модулей, импортированы в `SharedModule`. Вы должны импортировать `SharedModule` во все модули. 

Смотри [Sharing Modules](https://angular.io/guide/sharing-ngmodules).

#### Environments

Файлы в папке `src/environments` содержат конфигурацию среды исполнения приложения. 

#### Home Module

Home module это пример модуля с отложенной загрузкой, который загружается при обращении по корневому адресу приложения

#### Styles

Необходимые файлы стилей добавлены в массив `styles` в `angular.json`. `AppComponent` лениво загружает только некоторые файлы стилей через  `LazyLoadService` после загрузки основного пакета, чтобы сократить время первого рендеринга. 

#### Тестирование 

Вы должны создавать свои тесты в той же папке, что и файл, который вы хотите тестировать. 

Смотри [testing document](https://angular.io/guide/testing).

#### Зависимые пакеты 

* [NG Bootstrap](https://ng-bootstrap.github.io/) используется как библиотека компонентов пользовательского интерфейса. 
* [NGXS](https://www.ngxs.io/) используется как библиотека предсказуемого состояния контейнера.
* [angular-oauth2-oidc](https://github.com/manfredsteyer/angular-oauth2-oidc) используется для поддержки OAuth 2 и OpenId Connect (OIDC) .
* [Chart.js](https://www.chartjs.org/) используется для создания виджетов. 
* [ngx-validate](https://github.com/ng-turkey/ngx-validate) используется для динамической проверки реактивных форм. 

### React Native

если при создании нового проекта будет указана опция `-m react-native`, решение будет включать в себя приложение [React Native](https://reactnative.dev/) в папке `react-native`.

На стороне сервера аналогично описанному выше решению. Проект `* .HttpApi.Host` обслуживает API, поэтому приложение React Native будет использовать его.

Приложение React Native было создано с помощью [Expo](https://expo.io/). Expo - это набор инструментов, созданных на основе React Native, которые помогут вам быстро запустить приложение со множеством функций.

Структура папок приложения React Native, как показано ниже: 

![react-native-folder-structure](../images/react-native-folder-structure.png)

* `App.js` является загрузочным компонентом приложения.
* `Environment.js` этот файл содердит `prod` и `dev` конфигурации приложения. 
* [Contexts](https://reactjs.org/docs/context.html) создаются в папке `src/contexts`.
* [Higher order components](https://reactjs.org/docs/higher-order-components.html) создаются в папке `src/hocs`.
* [Custom hooks](https://reactjs.org/docs/hooks-custom.html#extracting-a-custom-hook) создаются в папке `src/hooks`.
* [Axios interceptors](https://github.com/axios/axios#interceptors) создаются в папке `src/interceptors`.
* Служебные функции экспортируются из папки `src/utils`.

#### Components

Компоненты, которые можно использовать на всех экранах, создаются в папке `src/components`. Все компоненты созданы как функции, которые могут использовать [hooks](https://reactjs.org/docs/hooks-intro.html).

#### Screens

![react-native-navigation-structure](../images/react-native-navigation-structure.png)

Экраны создаются путем создания папок, разделяющих их имена в папке `src/screens`. Определенные части некоторых экранов можно разделить на компоненты.

Каждый экран используется в навигаторе в папке `src/navigators`. 

#### Navigation

[React Navigation](https://reactnavigation.org/) используется как библиотека навигации. Навигаторы создаются в `src/navigators`.[drawer](https://reactnavigation.org/docs/drawer-based-navigation/) навигатор и несколько [stack](https://reactnavigation.org/docs/hello-react-navigation/#installing-the-stack-navigator-library) в этой папке созданы навигаторы. См. [above diagram](#screens) для структуры навигации.

#### Менаджер состояний

[Redux](https://redux.js.org/) используется как менеджер состояний. [Redux Toolkit](https://redux-toolkit.js.org/) библиотека используется как набор инструментов для эффективной разработки с Redux. 

Действия, редукторы, саги, селекторы создаются в папке `src/store`. папка хранилища, описана ниже: 

![react-native-store-folder](../images/react-native-store-folder.png)

* [**Store**](https://redux.js.org/basics/store) определяется в файле `src/store/index.js`.
* [**Actions**](https://redux.js.org/basics/actions/) это структуры, которые передают данные из вашего приложения в хранилище.
* [**Reducers**](https://redux.js.org/basics/reducers) указывают, как изменяется состояние приложения в ответ на действия, отправленные в хранилище. 
* [**Redux-Saga**](https://redux-saga.js.org/)  это библиотека нацеленная делать сайд-эффекты проще и лучше путем работы с сагами (т.е. асинхронные вызовы работа с промежуточными результатами или кешем браузера). Саги создаются в папке `src/store/sagas`.
* [**Reselect**](https://github.com/reduxjs/reselect)  это библиотека используется для создания мемоизированных селекторов (memoized selectors). Создаются в папке `src/store/selectors`.

#### APIs

[Axios](https://github.com/axios/axios)  это библиотека используется как HTTP клиент. Экземпляр Axios экспортирован из файла `src/api/API.js` для выполнения HTTP-вызовов. В папке `src/api` есть файлы API, созданные для вызовов API.

#### Theming

[Native Base](https://nativebase.io/) используется как библиотека компонентов пользовательского интерфейса. Компоненты Native Base можно легко настроить. См. Документацию [Native Base customize](https://docs.nativebase.io/Customize.html#Customize).  Мы пошли по тому же пути. 
 
* Native Base переменные темы находятся в папке `src/theme/variables`.
* Native Base Стили компонентов находятся в папке `src/theme/components`. Эти файлы были созданы с помощью сценария Native Base's `ejectTheme`.
* Стили компонентов могут перекрыватся файлами в папке `src/theme/overrides`.

#### Testing

Будут созданы юнит-тесты. 

Смотри [Testing Overview](https://reactjs.org/docs/testing.html).

#### Зависимые библиотеки

* [Native Base](https://nativebase.io/) используется в качестве библиотеки компонентов пользовательского интерфейса.
* [React Navigation](https://reactnavigation.org/) используется в качестве библиотеки навигации.
* [Axios](https://github.com/axios/axios) это библиотека используется как HTTP клиент.
* [Redux](https://redux.js.org/) используется как библиотека управления состоянием.
* [Redux Toolkit](https://redux-toolkit.js.org/)  используется в качестве набора инструментов для эффективной разработки с использованием Redux.
* [Redux-Saga](https://redux-saga.js.org/) используется для управления асинхронными процессами.
* [Redux Persist](https://github.com/rt2zz/redux-persist) используется для сохранения состояния.
* [Reselect](https://github.com/reduxjs/reselect) это библиотека используется для создания мемоизированных селекторов (memoized selectors)
* [i18n-js](https://github.com/fnando/i18n-js) используется для интенацианализации(i18n).
* [expo-font](https://docs.expo.io/versions/latest/sdk/font/) позволяет легко загружать шрифты.
* [Formik](https://github.com/jaredpalmer/formik) используется для создания форм.
* [Yup](https://github.com/jquense/yup) используется для валидации формы.

## вход через социальные сети/внешние сервисы

Если вы хотите настроить для своего приложения вход через социальные сети/внешние сервисы, следуйте инструкциям в документе [Social/External Logins](../Authentication/Social-External-Logins.md). 

## Что дальше?

- [The getting started document](../Getting-Started.md) как создать новое приложение за несколько минут.
- [The application development tutorial](../Tutorials/Part-1.md) пошаговая разработка приложения. 
